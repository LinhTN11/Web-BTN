{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\trann\\\\Desktop\\\\jwt-bt\\\\frontend\\\\src\\\\contexts\\\\ChatContext.tsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useState, useEffect, useCallback } from 'react';\nimport { useAuth } from './AuthContext';\nimport { chatService } from '../services/chatService';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst CACHE_DURATION = 2 * 60 * 1000; // 2 minutes for chat data\n\nconst ChatContext = /*#__PURE__*/createContext(undefined);\nexport const ChatProvider = ({\n  children\n}) => {\n  _s();\n  const {\n    user,\n    token\n  } = useAuth();\n  const [chatData, setChatData] = useState({\n    activeUsers: [],\n    messagesByConversation: {},\n    lastUsersFetch: 0,\n    lastMessagesFetch: {}\n  });\n  const [isLoadingUsers, setIsLoadingUsers] = useState(false);\n  const [isLoadingMessages, setIsLoadingMessages] = useState(false);\n  const [selectedUser, setSelectedUser] = useState(null); // Preload active users when context initializes\n  useEffect(() => {\n    if (user && token) {\n      refreshActiveUsers();\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [user, token]);\n  const refreshActiveUsers = useCallback(async () => {\n    if (!user) return;\n    try {\n      // Check cache validity\n      const now = Date.now();\n      if (now - chatData.lastUsersFetch < CACHE_DURATION && chatData.activeUsers.length > 0) {\n        return;\n      }\n      setIsLoadingUsers(true);\n      const users = await chatService.getActiveUsers();\n      const filteredUsers = users.filter(u => u._id !== user._id);\n      setChatData(prev => ({\n        ...prev,\n        activeUsers: filteredUsers,\n        lastUsersFetch: now\n      }));\n\n      // Auto-select first user if no user is selected\n      if (!selectedUser && filteredUsers.length > 0) {\n        setSelectedUser(filteredUsers[0]);\n      }\n    } catch (error) {\n      console.error('Error loading active users:', error);\n    } finally {\n      setIsLoadingUsers(false);\n    }\n  }, [user, chatData.lastUsersFetch, chatData.activeUsers.length, selectedUser]);\n  const loadMessages = useCallback(async userId => {\n    try {\n      var _chatData$messagesByC;\n      // Check cache validity\n      const now = Date.now();\n      const lastFetch = chatData.lastMessagesFetch[userId] || 0;\n      if (now - lastFetch < CACHE_DURATION && ((_chatData$messagesByC = chatData.messagesByConversation[userId]) === null || _chatData$messagesByC === void 0 ? void 0 : _chatData$messagesByC.length) > 0) {\n        return;\n      }\n      setIsLoadingMessages(true);\n      const messages = await chatService.getMessages(userId);\n      const sortedMessages = messages.sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());\n      setChatData(prev => ({\n        ...prev,\n        messagesByConversation: {\n          ...prev.messagesByConversation,\n          [userId]: sortedMessages\n        },\n        lastMessagesFetch: {\n          ...prev.lastMessagesFetch,\n          [userId]: now\n        }\n      }));\n    } catch (error) {\n      console.error('Error loading messages:', error);\n    } finally {\n      setIsLoadingMessages(false);\n    }\n  }, [chatData.lastMessagesFetch, chatData.messagesByConversation]);\n  const sendMessage = useCallback(async (userId, content) => {\n    try {\n      const newMessage = await chatService.sendMessage(userId, content);\n\n      // Add message to local state immediately for better UX\n      setChatData(prev => ({\n        ...prev,\n        messagesByConversation: {\n          ...prev.messagesByConversation,\n          [userId]: [...(prev.messagesByConversation[userId] || []), newMessage]\n        }\n      }));\n    } catch (error) {\n      console.error('Error sending message:', error);\n      throw error;\n    }\n  }, []);\n  const addMessage = useCallback(message => {\n    // Helper function to get ID from sender/receiver which can be string or object\n    const getSenderId = sender => {\n      return typeof sender === 'string' ? sender : sender._id;\n    };\n    const senderId = getSenderId(message.sender);\n    const receiverId = getSenderId(message.receiver);\n    const otherUserId = senderId === (user === null || user === void 0 ? void 0 : user._id) ? receiverId : senderId;\n    setChatData(prev => ({\n      ...prev,\n      messagesByConversation: {\n        ...prev.messagesByConversation,\n        [otherUserId]: [...(prev.messagesByConversation[otherUserId] || []), message]\n      }\n    }));\n  }, [user === null || user === void 0 ? void 0 : user._id]);\n  const markAsRead = useCallback(async userId => {\n    try {\n      await chatService.markAsRead(userId);\n\n      // Helper function to get ID from sender/receiver which can be string or object\n      const getReceiverId = receiver => {\n        return typeof receiver === 'string' ? receiver : receiver._id;\n      };\n\n      // Update local messages to mark as read\n      setChatData(prev => ({\n        ...prev,\n        messagesByConversation: {\n          ...prev.messagesByConversation,\n          [userId]: (prev.messagesByConversation[userId] || []).map(msg => ({\n            ...msg,\n            read: getReceiverId(msg.receiver) === (user === null || user === void 0 ? void 0 : user._id) ? true : msg.read\n          }))\n        }\n      }));\n    } catch (error) {\n      console.error('Error marking messages as read:', error);\n    }\n  }, [user === null || user === void 0 ? void 0 : user._id]);\n  const value = {\n    activeUsers: chatData.activeUsers,\n    messagesByConversation: chatData.messagesByConversation,\n    isLoadingUsers,\n    isLoadingMessages,\n    selectedUser,\n    setSelectedUser,\n    loadMessages,\n    refreshActiveUsers,\n    sendMessage,\n    addMessage,\n    markAsRead\n  };\n  return /*#__PURE__*/_jsxDEV(ChatContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 191,\n    columnNumber: 5\n  }, this);\n};\n_s(ChatProvider, \"RrwGsU+sRbRIzSBbQuN3cxPuafo=\", false, function () {\n  return [useAuth];\n});\n_c = ChatProvider;\nexport const useChat = () => {\n  _s2();\n  const context = useContext(ChatContext);\n  if (context === undefined) {\n    throw new Error('useChat must be used within a ChatProvider');\n  }\n  return context;\n};\n_s2(useChat, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"ChatProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useEffect","useCallback","useAuth","chatService","jsxDEV","_jsxDEV","CACHE_DURATION","ChatContext","undefined","ChatProvider","children","_s","user","token","chatData","setChatData","activeUsers","messagesByConversation","lastUsersFetch","lastMessagesFetch","isLoadingUsers","setIsLoadingUsers","isLoadingMessages","setIsLoadingMessages","selectedUser","setSelectedUser","refreshActiveUsers","now","Date","length","users","getActiveUsers","filteredUsers","filter","u","_id","prev","error","console","loadMessages","userId","_chatData$messagesByC","lastFetch","messages","getMessages","sortedMessages","sort","a","b","timestamp","getTime","sendMessage","content","newMessage","addMessage","message","getSenderId","sender","senderId","receiverId","receiver","otherUserId","markAsRead","getReceiverId","map","msg","read","value","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","useChat","_s2","context","Error","$RefreshReg$"],"sources":["C:/Users/trann/Desktop/jwt-bt/frontend/src/contexts/ChatContext.tsx"],"sourcesContent":["import React, { createContext, useContext, useState, useEffect, ReactNode, useCallback } from 'react';\r\nimport { useAuth } from './AuthContext';\r\nimport { chatService, ChatUser, Message, MessageUser } from '../services/chatService';\r\n\r\ninterface ChatContextType {\r\n  activeUsers: ChatUser[];\r\n  messagesByConversation: { [key: string]: Message[] };\r\n  isLoadingUsers: boolean;\r\n  isLoadingMessages: boolean;\r\n  selectedUser: ChatUser | null;\r\n  setSelectedUser: (user: ChatUser | null) => void;\r\n  loadMessages: (userId: string) => Promise<void>;\r\n  refreshActiveUsers: () => Promise<void>;\r\n  sendMessage: (userId: string, content: string) => Promise<void>;\r\n  addMessage: (message: Message) => void;\r\n  markAsRead: (userId: string) => Promise<void>;\r\n}\r\n\r\ninterface ChatData {\r\n  activeUsers: ChatUser[];\r\n  messagesByConversation: { [key: string]: Message[] };\r\n  lastUsersFetch: number;\r\n  lastMessagesFetch: { [key: string]: number };\r\n}\r\n\r\nconst CACHE_DURATION = 2 * 60 * 1000; // 2 minutes for chat data\r\n\r\nconst ChatContext = createContext<ChatContextType | undefined>(undefined);\r\n\r\ninterface ChatProviderProps {\r\n  children: ReactNode;\r\n}\r\n\r\nexport const ChatProvider: React.FC<ChatProviderProps> = ({ children }) => {\r\n  const { user, token } = useAuth();\r\n  const [chatData, setChatData] = useState<ChatData>({\r\n    activeUsers: [],\r\n    messagesByConversation: {},\r\n    lastUsersFetch: 0,\r\n    lastMessagesFetch: {}\r\n  });\r\n  const [isLoadingUsers, setIsLoadingUsers] = useState(false);\r\n  const [isLoadingMessages, setIsLoadingMessages] = useState(false);\r\n  const [selectedUser, setSelectedUser] = useState<ChatUser | null>(null);  // Preload active users when context initializes\r\n  useEffect(() => {\r\n    if (user && token) {\r\n      refreshActiveUsers();\r\n    }\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [user, token]);\r\n\r\n  const refreshActiveUsers = useCallback(async () => {\r\n    if (!user) return;\r\n\r\n    try {\r\n      // Check cache validity\r\n      const now = Date.now();\r\n      if (now - chatData.lastUsersFetch < CACHE_DURATION && chatData.activeUsers.length > 0) {\r\n        return;\r\n      }\r\n\r\n      setIsLoadingUsers(true);\r\n      const users = await chatService.getActiveUsers();\r\n      const filteredUsers = users.filter(u => u._id !== user._id);\r\n      \r\n      setChatData(prev => ({\r\n        ...prev,\r\n        activeUsers: filteredUsers,\r\n        lastUsersFetch: now\r\n      }));\r\n\r\n      // Auto-select first user if no user is selected\r\n      if (!selectedUser && filteredUsers.length > 0) {\r\n        setSelectedUser(filteredUsers[0]);\r\n      }\r\n    } catch (error) {\r\n      console.error('Error loading active users:', error);\r\n    } finally {\r\n      setIsLoadingUsers(false);\r\n    }\r\n  }, [user, chatData.lastUsersFetch, chatData.activeUsers.length, selectedUser]);\r\n\r\n  const loadMessages = useCallback(async (userId: string) => {\r\n    try {\r\n      // Check cache validity\r\n      const now = Date.now();\r\n      const lastFetch = chatData.lastMessagesFetch[userId] || 0;\r\n      if (now - lastFetch < CACHE_DURATION && chatData.messagesByConversation[userId]?.length > 0) {\r\n        return;\r\n      }\r\n\r\n      setIsLoadingMessages(true);\r\n      const messages = await chatService.getMessages(userId);\r\n      const sortedMessages = messages.sort((a, b) => \r\n        new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime()\r\n      );\r\n      \r\n      setChatData(prev => ({\r\n        ...prev,\r\n        messagesByConversation: {\r\n          ...prev.messagesByConversation,\r\n          [userId]: sortedMessages\r\n        },\r\n        lastMessagesFetch: {\r\n          ...prev.lastMessagesFetch,\r\n          [userId]: now\r\n        }\r\n      }));\r\n    } catch (error) {\r\n      console.error('Error loading messages:', error);\r\n    } finally {\r\n      setIsLoadingMessages(false);\r\n    }\r\n  }, [chatData.lastMessagesFetch, chatData.messagesByConversation]);\r\n\r\n  const sendMessage = useCallback(async (userId: string, content: string) => {\r\n    try {\r\n      const newMessage = await chatService.sendMessage(userId, content);\r\n      \r\n      // Add message to local state immediately for better UX\r\n      setChatData(prev => ({\r\n        ...prev,\r\n        messagesByConversation: {\r\n          ...prev.messagesByConversation,\r\n          [userId]: [...(prev.messagesByConversation[userId] || []), newMessage]\r\n        }\r\n      }));\r\n    } catch (error) {\r\n      console.error('Error sending message:', error);\r\n      throw error;\r\n    }\r\n  }, []);\r\n  const addMessage = useCallback((message: Message) => {\r\n    // Helper function to get ID from sender/receiver which can be string or object\r\n    const getSenderId = (sender: string | MessageUser): string => {\r\n      return typeof sender === 'string' ? sender : sender._id;\r\n    };\r\n    \r\n    const senderId = getSenderId(message.sender);\r\n    const receiverId = getSenderId(message.receiver);\r\n    const otherUserId = senderId === user?._id ? receiverId : senderId;\r\n    \r\n    setChatData(prev => ({\r\n      ...prev,\r\n      messagesByConversation: {\r\n        ...prev.messagesByConversation,\r\n        [otherUserId]: [...(prev.messagesByConversation[otherUserId] || []), message]\r\n      }\r\n    }));\r\n  }, [user?._id]);\r\n  const markAsRead = useCallback(async (userId: string) => {\r\n    try {\r\n      await chatService.markAsRead(userId);\r\n      \r\n      // Helper function to get ID from sender/receiver which can be string or object\r\n      const getReceiverId = (receiver: string | MessageUser): string => {\r\n        return typeof receiver === 'string' ? receiver : receiver._id;\r\n      };\r\n      \r\n      // Update local messages to mark as read\r\n      setChatData(prev => ({\r\n        ...prev,\r\n        messagesByConversation: {\r\n          ...prev.messagesByConversation,\r\n          [userId]: (prev.messagesByConversation[userId] || []).map(msg => ({\r\n            ...msg,\r\n            read: getReceiverId(msg.receiver) === user?._id ? true : msg.read\r\n          }))\r\n        }\r\n      }));\r\n    } catch (error) {\r\n      console.error('Error marking messages as read:', error);\r\n    }\r\n  }, [user?._id]);\r\n\r\n  const value: ChatContextType = {\r\n    activeUsers: chatData.activeUsers,\r\n    messagesByConversation: chatData.messagesByConversation,\r\n    isLoadingUsers,\r\n    isLoadingMessages,\r\n    selectedUser,\r\n    setSelectedUser,\r\n    loadMessages,\r\n    refreshActiveUsers,\r\n    sendMessage,\r\n    addMessage,\r\n    markAsRead\r\n  };\r\n\r\n  return (\r\n    <ChatContext.Provider value={value}>\r\n      {children}\r\n    </ChatContext.Provider>\r\n  );\r\n};\r\n\r\nexport const useChat = (): ChatContextType => {\r\n  const context = useContext(ChatContext);\r\n  if (context === undefined) {\r\n    throw new Error('useChat must be used within a ChatProvider');\r\n  }\r\n  return context;\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}