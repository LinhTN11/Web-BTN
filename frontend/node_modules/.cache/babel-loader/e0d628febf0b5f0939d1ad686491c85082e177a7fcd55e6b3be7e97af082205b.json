{"ast":null,"code":"import { io } from 'socket.io-client';\nclass SocketService {\n  constructor() {\n    this.socket = null;\n    this.messageCallbacks = [];\n    this.userOnlineCallbacks = [];\n    this.userOfflineCallbacks = [];\n    this.typingCallbacks = [];\n    this.heartbeatInterval = null;\n    this.reconnectInterval = null;\n    this.currentToken = null;\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 50;\n    // Add message deduplication\n    this.pendingMessages = new Set();\n  }\n  connect(token) {\n    this.currentToken = token;\n    if (!this.socket || this.socket.disconnected) {\n      this.socket = io(process.env.REACT_APP_API_URL || 'http://localhost:8000', {\n        auth: {\n          token\n        },\n        transports: ['websocket', 'polling'],\n        reconnection: true,\n        reconnectionDelay: 1000,\n        reconnectionDelayMax: 5000,\n        reconnectionAttempts: this.maxReconnectAttempts,\n        forceNew: true,\n        timeout: 10000,\n        closeOnBeforeunload: false\n      });\n      this.socket.on('connect', () => {\n        console.log('✅ Socket connected successfully');\n        this.reconnectAttempts = 0;\n        this.clearReconnectInterval();\n        this.startHeartbeat();\n      });\n      this.socket.on('reconnect', attemptNumber => {\n        console.log('✅ Socket reconnected after', attemptNumber, 'attempts');\n        this.reconnectAttempts = 0;\n        this.clearReconnectInterval();\n        this.startHeartbeat();\n      });\n      this.socket.on('reconnect_attempt', attemptNumber => {\n        console.log('🔄 Reconnection attempt:', attemptNumber);\n        this.reconnectAttempts = attemptNumber;\n      });\n      this.socket.on('connect_error', error => {\n        console.error('❌ Socket connection error:', error);\n\n        // If error is related to authentication, try to refresh token\n        if (error.message.includes('Authentication error') || error.message.includes('Invalid token')) {\n          console.log('🔑 Authentication error detected, attempting token refresh...');\n          this.handleAuthError();\n        }\n      });\n      this.socket.on('disconnect', reason => {\n        console.log('🔌 Socket disconnected:', reason);\n        this.stopHeartbeat();\n\n        // Handle different disconnect reasons\n        if (reason === 'io server disconnect' || reason === 'io client disconnect') {\n          console.log('⚠️ Permanent disconnect detected');\n        } else {\n          console.log('🔄 Temporary disconnect, will attempt reconnect...');\n          this.startReconnectAttempts();\n        }\n      });\n      this.socket.on('reconnect_failed', () => {\n        console.error('❌ Socket failed to reconnect after all attempts');\n        this.startReconnectAttempts();\n      });\n      this.socket.on('reconnect_error', error => {\n        console.error('❌ Socket reconnection error:', error);\n        if (error.message.includes('Authentication error') || error.message.includes('Invalid token')) {\n          this.handleAuthError();\n        }\n      }); // Message events với tối ưu hiệu suất\n      this.socket.on('newMessage', message => {\n        console.log('📨 Received new message:', message);\n        this.messageCallbacks.forEach(callback => callback(message));\n      });\n      this.socket.on('messageConfirmed', confirmation => {\n        console.log('✅ Message confirmed:', confirmation);\n        // Handle both old format (full message) and new optimized format\n        if (confirmation.type === 'messageConfirmed') {\n          // New optimized format (📦 Gói tin nhỏ)\n          console.log('📦 Received optimized confirmation:', confirmation);\n          // Don't call message callbacks for optimized confirmations as they don't contain full message data\n        } else if (confirmation._id && confirmation.sender && confirmation.receiver) {\n          // Legacy format - treat as message only if it has required properties\n          this.messageCallbacks.forEach(callback => callback(confirmation));\n        } else {\n          console.warn('⚠️ Received messageConfirmed with incomplete data:', confirmation);\n        }\n      });\n\n      // Re-auth events (🔁 Re-auth qua sự kiện socket)\n      this.socket.on('reauth_success', data => {\n        console.log('✅ Re-authentication successful:', data);\n      });\n      this.socket.on('reauth_error', error => {\n        console.error('❌ Re-authentication failed:', error);\n        this.handleAuthError();\n      });\n      this.socket.on('messageError', error => {\n        console.error('❌ Message error:', error);\n      });\n\n      // User status events\n      this.socket.on('userOnline', userId => {\n        this.userOnlineCallbacks.forEach(callback => callback(userId));\n      });\n      this.socket.on('userOffline', userId => {\n        this.userOfflineCallbacks.forEach(callback => callback(userId));\n      });\n\n      // Typing events\n      this.socket.on('userTyping', data => {\n        this.typingCallbacks.forEach(callback => callback(data));\n      });\n    }\n    return this.socket;\n  }\n  disconnect() {\n    this.stopHeartbeat();\n    this.clearReconnectInterval();\n    if (this.socket) {\n      this.socket.removeAllListeners();\n      this.socket.disconnect();\n      this.socket = null;\n    }\n  }\n  forceReconnect(token) {\n    console.log('🔄 Force reconnecting socket...');\n    this.disconnect();\n    return this.connect(token);\n  }\n  isConnected() {\n    return this.socket && this.socket.connected;\n  }\n  startHeartbeat() {\n    this.stopHeartbeat();\n    // Send heartbeat every 15 seconds to keep connection alive\n    this.heartbeatInterval = setInterval(() => {\n      if (this.socket && this.socket.connected) {\n        this.socket.emit('heartbeat');\n        console.log('💓 Heartbeat sent');\n      }\n    }, 15000);\n  }\n  stopHeartbeat() {\n    if (this.heartbeatInterval) {\n      clearInterval(this.heartbeatInterval);\n      this.heartbeatInterval = null;\n    }\n  }\n  clearReconnectInterval() {\n    if (this.reconnectInterval) {\n      clearInterval(this.reconnectInterval);\n      this.reconnectInterval = null;\n    }\n  }\n  startReconnectAttempts() {\n    if (this.reconnectInterval) return; // Already trying to reconnect\n\n    this.reconnectInterval = setInterval(async () => {\n      if (this.reconnectAttempts >= this.maxReconnectAttempts) {\n        console.log('⚠️ Max reconnect attempts reached, trying token refresh...');\n        await this.handleAuthError();\n        return;\n      }\n      if (!this.isConnected() && this.currentToken) {\n        console.log(`🔄 Manual reconnect attempt ${this.reconnectAttempts + 1}/${this.maxReconnectAttempts}`);\n        this.reconnectAttempts++;\n        this.forceReconnect(this.currentToken);\n      } else if (this.isConnected()) {\n        console.log('✅ Socket reconnected successfully');\n        this.clearReconnectInterval();\n        this.reconnectAttempts = 0;\n      }\n    }, 5000);\n  }\n  async handleAuthError() {\n    try {\n      console.log('🔑 Attempting to refresh token...');\n\n      // Try to refresh token using localStorage directly\n      const response = await fetch(`${process.env.REACT_APP_API_URL || 'http://localhost:8000'}/v1/auth/refresh`, {\n        method: 'POST',\n        credentials: 'include',\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      });\n      if (response.ok) {\n        const data = await response.json();\n        const newToken = data.accessToken;\n\n        // Update localStorage\n        localStorage.setItem('token', newToken);\n        this.currentToken = newToken;\n        console.log('✅ Token refreshed, reconnecting socket...');\n        this.forceReconnect(newToken);\n      } else {\n        console.error('❌ Token refresh failed, redirecting to login...');\n        localStorage.removeItem('token');\n        localStorage.removeItem('user');\n        window.location.href = '/login';\n      }\n    } catch (error) {\n      console.error('❌ Error during token refresh:', error);\n      localStorage.removeItem('token');\n      localStorage.removeItem('user');\n      window.location.href = '/login';\n    }\n  }\n\n  // Method to update token when it's refreshed externally\n  updateToken(newToken) {\n    if (this.currentToken !== newToken) {\n      console.log('🔑 Updating socket token...');\n      this.currentToken = newToken;\n      if (this.isConnected()) {\n        // Use re-auth instead of reconnect for better performance (🔁 Re-auth qua sự kiện socket)\n        this.reauth(newToken);\n      }\n    }\n  }\n\n  // Re-authenticate with new token without disconnecting (⏱️ Token gần hết hạn thì reconnect)\n  reauth(newToken) {\n    if (this.socket && this.socket.connected) {\n      console.log('🔄 Re-authenticating with new token...');\n      this.socket.emit('reauth', {\n        token: newToken\n      });\n    } else {\n      console.log('🔄 Socket not connected, forcing reconnect...');\n      this.forceReconnect(newToken);\n    }\n  }\n  sendMessage(receiverId, content, messageType = 'text') {\n    if (this.socket && this.socket.connected) {\n      // Create a unique key for this message to prevent duplicates\n      const messageKey = `${receiverId}-${content}-${Date.now()}`;\n      if (this.pendingMessages.has(messageKey)) {\n        console.log('⚠️ Duplicate message detected, skipping:', messageKey);\n        return;\n      }\n      this.pendingMessages.add(messageKey);\n\n      // Remove from pending after 10 seconds\n      setTimeout(() => {\n        this.pendingMessages.delete(messageKey);\n      }, 10000);\n      console.log('📤 Sending message:', {\n        receiverId,\n        content: content.substring(0, 50),\n        messageKey\n      });\n      this.socket.emit('sendMessage', {\n        receiverId,\n        content,\n        messageType\n      });\n    } else {\n      console.warn('⚠️ Socket not connected, cannot send message');\n    }\n  }\n  onMessage(callback) {\n    this.messageCallbacks.push(callback);\n    return () => this.removeMessageCallback(callback);\n  }\n  onUserOnline(callback) {\n    this.userOnlineCallbacks.push(callback);\n    return () => this.removeUserOnlineCallback(callback);\n  }\n  onUserOffline(callback) {\n    this.userOfflineCallbacks.push(callback);\n    return () => this.removeUserOfflineCallback(callback);\n  }\n\n  // Keep for backward compatibility\n  onUserStatus(callback) {\n    return this.onUserOnline(callback);\n  }\n  onTyping(callback) {\n    this.typingCallbacks.push(callback);\n    return () => this.removeTypingCallback(callback);\n  }\n  sendTypingStatus(receiverId, isTyping) {\n    if (this.socket && this.socket.connected) {\n      this.socket.emit('typing', {\n        receiverId,\n        isTyping\n      });\n    }\n  }\n  markAsRead(senderId) {\n    if (this.socket && this.socket.connected) {\n      this.socket.emit('markAsRead', {\n        senderId\n      });\n    }\n  }\n  off(event) {\n    if (this.socket) {\n      this.socket.off(event);\n    }\n  }\n  getSocket() {\n    return this.socket;\n  }\n\n  // Add method to get current connection status more reliably\n  getConnectionStatus() {\n    return {\n      isConnected: this.socket && this.socket.connected,\n      socket: this.socket,\n      currentToken: this.currentToken,\n      reconnectAttempts: this.reconnectAttempts\n    };\n  }\n\n  // Force state sync for debugging\n  forceStateSync() {\n    var _this$socket, _this$socket2;\n    console.log('🔍 Socket state debug:', {\n      hasSocket: !!this.socket,\n      isConnected: (_this$socket = this.socket) === null || _this$socket === void 0 ? void 0 : _this$socket.connected,\n      socketId: (_this$socket2 = this.socket) === null || _this$socket2 === void 0 ? void 0 : _this$socket2.id,\n      currentToken: !!this.currentToken,\n      reconnectAttempts: this.reconnectAttempts\n    });\n    return this.socket && this.socket.connected;\n  }\n  removeMessageCallback(callback) {\n    this.messageCallbacks = this.messageCallbacks.filter(cb => cb !== callback);\n  }\n  removeUserOnlineCallback(callback) {\n    this.userOnlineCallbacks = this.userOnlineCallbacks.filter(cb => cb !== callback);\n  }\n  removeUserOfflineCallback(callback) {\n    this.userOfflineCallbacks = this.userOfflineCallbacks.filter(cb => cb !== callback);\n  }\n  removeTypingCallback(callback) {\n    this.typingCallbacks = this.typingCallbacks.filter(cb => cb !== callback);\n  }\n}\nexport const socketService = new SocketService();\nexport default socketService;","map":{"version":3,"names":["io","SocketService","constructor","socket","messageCallbacks","userOnlineCallbacks","userOfflineCallbacks","typingCallbacks","heartbeatInterval","reconnectInterval","currentToken","reconnectAttempts","maxReconnectAttempts","pendingMessages","Set","connect","token","disconnected","process","env","REACT_APP_API_URL","auth","transports","reconnection","reconnectionDelay","reconnectionDelayMax","reconnectionAttempts","forceNew","timeout","closeOnBeforeunload","on","console","log","clearReconnectInterval","startHeartbeat","attemptNumber","error","message","includes","handleAuthError","reason","stopHeartbeat","startReconnectAttempts","forEach","callback","confirmation","type","_id","sender","receiver","warn","data","userId","disconnect","removeAllListeners","forceReconnect","isConnected","connected","setInterval","emit","clearInterval","response","fetch","method","credentials","headers","ok","json","newToken","accessToken","localStorage","setItem","removeItem","window","location","href","updateToken","reauth","sendMessage","receiverId","content","messageType","messageKey","Date","now","has","add","setTimeout","delete","substring","onMessage","push","removeMessageCallback","onUserOnline","removeUserOnlineCallback","onUserOffline","removeUserOfflineCallback","onUserStatus","onTyping","removeTypingCallback","sendTypingStatus","isTyping","markAsRead","senderId","off","event","getSocket","getConnectionStatus","forceStateSync","_this$socket","_this$socket2","hasSocket","socketId","id","filter","cb","socketService"],"sources":["C:/Users/trann/Desktop/jwt-bt/frontend/src/services/socketService.ts"],"sourcesContent":["import { io, Socket } from 'socket.io-client';\r\nimport { Message } from './chatService';\r\n\r\ntype MessageCallback = (message: Message) => void;\r\ntype UserOnlineCallback = (userId: string) => void;\r\ntype UserOfflineCallback = (userId: string) => void;\r\ntype TypingCallback = (data: { userId: string, isTyping: boolean }) => void;\r\n\r\nclass SocketService {\r\n  private socket: Socket | null = null;\r\n  private messageCallbacks: MessageCallback[] = [];\r\n  private userOnlineCallbacks: UserOnlineCallback[] = [];\r\n  private userOfflineCallbacks: UserOfflineCallback[] = [];\r\n  private typingCallbacks: TypingCallback[] = [];\r\n  private heartbeatInterval: NodeJS.Timeout | null = null;\r\n  private reconnectInterval: NodeJS.Timeout | null = null;\r\n  private currentToken: string | null = null;\r\n  private reconnectAttempts = 0;\r\n  private maxReconnectAttempts = 50;\r\n\r\n  // Add message deduplication\r\n  private pendingMessages = new Set<string>();\r\n\r\n  connect(token: string) {\r\n    this.currentToken = token;\r\n    \r\n    if (!this.socket || this.socket.disconnected) {\r\n      this.socket = io(process.env.REACT_APP_API_URL || 'http://localhost:8000', {\r\n        auth: { token },\r\n        transports: ['websocket', 'polling'],\r\n        reconnection: true,\r\n        reconnectionDelay: 1000,\r\n        reconnectionDelayMax: 5000,\r\n        reconnectionAttempts: this.maxReconnectAttempts,\r\n        forceNew: true,\r\n        timeout: 10000,\r\n        closeOnBeforeunload: false\r\n      });\r\n\r\n      this.socket.on('connect', () => {\r\n        console.log('✅ Socket connected successfully');\r\n        this.reconnectAttempts = 0;\r\n        this.clearReconnectInterval();\r\n        this.startHeartbeat();\r\n      });\r\n\r\n      this.socket.on('reconnect', (attemptNumber) => {\r\n        console.log('✅ Socket reconnected after', attemptNumber, 'attempts');\r\n        this.reconnectAttempts = 0;\r\n        this.clearReconnectInterval();\r\n        this.startHeartbeat();\r\n      });\r\n\r\n      this.socket.on('reconnect_attempt', (attemptNumber) => {\r\n        console.log('🔄 Reconnection attempt:', attemptNumber);\r\n        this.reconnectAttempts = attemptNumber;\r\n      });\r\n\r\n      this.socket.on('connect_error', (error: Error) => {\r\n        console.error('❌ Socket connection error:', error);\r\n        \r\n        // If error is related to authentication, try to refresh token\r\n        if (error.message.includes('Authentication error') || error.message.includes('Invalid token')) {\r\n          console.log('🔑 Authentication error detected, attempting token refresh...');\r\n          this.handleAuthError();\r\n        }\r\n      });\r\n\r\n      this.socket.on('disconnect', (reason) => {\r\n        console.log('🔌 Socket disconnected:', reason);\r\n        this.stopHeartbeat();\r\n        \r\n        // Handle different disconnect reasons\r\n        if (reason === 'io server disconnect' || reason === 'io client disconnect') {\r\n          console.log('⚠️ Permanent disconnect detected');\r\n        } else {\r\n          console.log('🔄 Temporary disconnect, will attempt reconnect...');\r\n          this.startReconnectAttempts();\r\n        }\r\n      });\r\n\r\n      this.socket.on('reconnect_failed', () => {\r\n        console.error('❌ Socket failed to reconnect after all attempts');\r\n        this.startReconnectAttempts();\r\n      });\r\n\r\n      this.socket.on('reconnect_error', (error) => {\r\n        console.error('❌ Socket reconnection error:', error);\r\n        \r\n        if (error.message.includes('Authentication error') || error.message.includes('Invalid token')) {\r\n          this.handleAuthError();\r\n        }\r\n      });      // Message events với tối ưu hiệu suất\r\n      this.socket.on('newMessage', (message: Message) => {\r\n        console.log('📨 Received new message:', message);\r\n        this.messageCallbacks.forEach(callback => callback(message));\r\n      });      this.socket.on('messageConfirmed', (confirmation: any) => {\r\n        console.log('✅ Message confirmed:', confirmation);\r\n        // Handle both old format (full message) and new optimized format\r\n        if (confirmation.type === 'messageConfirmed') {\r\n          // New optimized format (📦 Gói tin nhỏ)\r\n          console.log('📦 Received optimized confirmation:', confirmation);\r\n          // Don't call message callbacks for optimized confirmations as they don't contain full message data\r\n        } else if (confirmation._id && confirmation.sender && confirmation.receiver) {\r\n          // Legacy format - treat as message only if it has required properties\r\n          this.messageCallbacks.forEach(callback => callback(confirmation));\r\n        } else {\r\n          console.warn('⚠️ Received messageConfirmed with incomplete data:', confirmation);\r\n        }\r\n      });\r\n\r\n      // Re-auth events (🔁 Re-auth qua sự kiện socket)\r\n      this.socket.on('reauth_success', (data) => {\r\n        console.log('✅ Re-authentication successful:', data);\r\n      });\r\n\r\n      this.socket.on('reauth_error', (error) => {\r\n        console.error('❌ Re-authentication failed:', error);\r\n        this.handleAuthError();\r\n      });\r\n\r\n      this.socket.on('messageError', (error: { error: string }) => {\r\n        console.error('❌ Message error:', error);\r\n      });\r\n\r\n      // User status events\r\n      this.socket.on('userOnline', (userId: string) => {\r\n        this.userOnlineCallbacks.forEach(callback => callback(userId));\r\n      });\r\n\r\n      this.socket.on('userOffline', (userId: string) => {\r\n        this.userOfflineCallbacks.forEach(callback => callback(userId));\r\n      });\r\n\r\n      // Typing events\r\n      this.socket.on('userTyping', (data: { userId: string, isTyping: boolean }) => {\r\n        this.typingCallbacks.forEach(callback => callback(data));\r\n      });\r\n    }\r\n    return this.socket;\r\n  }\r\n\r\n  disconnect() {\r\n    this.stopHeartbeat();\r\n    this.clearReconnectInterval();\r\n    if (this.socket) {\r\n      this.socket.removeAllListeners();\r\n      this.socket.disconnect();\r\n      this.socket = null;\r\n    }\r\n  }\r\n\r\n  forceReconnect(token: string) {\r\n    console.log('🔄 Force reconnecting socket...');\r\n    this.disconnect();\r\n    return this.connect(token);\r\n  }\r\n\r\n  isConnected() {\r\n    return this.socket && this.socket.connected;\r\n  }\r\n\r\n  private startHeartbeat() {\r\n    this.stopHeartbeat();\r\n    // Send heartbeat every 15 seconds to keep connection alive\r\n    this.heartbeatInterval = setInterval(() => {\r\n      if (this.socket && this.socket.connected) {\r\n        this.socket.emit('heartbeat');\r\n        console.log('💓 Heartbeat sent');\r\n      }\r\n    }, 15000);\r\n  }\r\n\r\n  private stopHeartbeat() {\r\n    if (this.heartbeatInterval) {\r\n      clearInterval(this.heartbeatInterval);\r\n      this.heartbeatInterval = null;\r\n    }\r\n  }\r\n\r\n  private clearReconnectInterval() {\r\n    if (this.reconnectInterval) {\r\n      clearInterval(this.reconnectInterval);\r\n      this.reconnectInterval = null;\r\n    }\r\n  }\r\n\r\n  private startReconnectAttempts() {\r\n    if (this.reconnectInterval) return; // Already trying to reconnect\r\n\r\n    this.reconnectInterval = setInterval(async () => {\r\n      if (this.reconnectAttempts >= this.maxReconnectAttempts) {\r\n        console.log('⚠️ Max reconnect attempts reached, trying token refresh...');\r\n        await this.handleAuthError();\r\n        return;\r\n      }\r\n\r\n      if (!this.isConnected() && this.currentToken) {\r\n        console.log(`🔄 Manual reconnect attempt ${this.reconnectAttempts + 1}/${this.maxReconnectAttempts}`);\r\n        this.reconnectAttempts++;\r\n        this.forceReconnect(this.currentToken);\r\n      } else if (this.isConnected()) {\r\n        console.log('✅ Socket reconnected successfully');\r\n        this.clearReconnectInterval();\r\n        this.reconnectAttempts = 0;\r\n      }\r\n    }, 5000);\r\n  }\r\n\r\n  private async handleAuthError() {\r\n    try {\r\n      console.log('🔑 Attempting to refresh token...');\r\n      \r\n      // Try to refresh token using localStorage directly\r\n      const response = await fetch(`${process.env.REACT_APP_API_URL || 'http://localhost:8000'}/v1/auth/refresh`, {\r\n        method: 'POST',\r\n        credentials: 'include',\r\n        headers: {\r\n          'Content-Type': 'application/json'\r\n        }\r\n      });\r\n\r\n      if (response.ok) {\r\n        const data = await response.json();\r\n        const newToken = data.accessToken;\r\n        \r\n        // Update localStorage\r\n        localStorage.setItem('token', newToken);\r\n        this.currentToken = newToken;\r\n        \r\n        console.log('✅ Token refreshed, reconnecting socket...');\r\n        this.forceReconnect(newToken);\r\n      } else {\r\n        console.error('❌ Token refresh failed, redirecting to login...');\r\n        localStorage.removeItem('token');\r\n        localStorage.removeItem('user');\r\n        window.location.href = '/login';\r\n      }\r\n    } catch (error) {\r\n      console.error('❌ Error during token refresh:', error);\r\n      localStorage.removeItem('token');\r\n      localStorage.removeItem('user');\r\n      window.location.href = '/login';\r\n    }  }\r\n\r\n  // Method to update token when it's refreshed externally\r\n  updateToken(newToken: string) {\r\n    if (this.currentToken !== newToken) {\r\n      console.log('🔑 Updating socket token...');\r\n      this.currentToken = newToken;\r\n      \r\n      if (this.isConnected()) {\r\n        // Use re-auth instead of reconnect for better performance (🔁 Re-auth qua sự kiện socket)\r\n        this.reauth(newToken);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Re-authenticate with new token without disconnecting (⏱️ Token gần hết hạn thì reconnect)\r\n  reauth(newToken: string) {\r\n    if (this.socket && this.socket.connected) {\r\n      console.log('🔄 Re-authenticating with new token...');\r\n      this.socket.emit('reauth', { token: newToken });\r\n    } else {\r\n      console.log('🔄 Socket not connected, forcing reconnect...');\r\n      this.forceReconnect(newToken);\r\n    }\r\n  }\r\n\r\n  sendMessage(receiverId: string, content: string, messageType: string = 'text') {\r\n    if (this.socket && this.socket.connected) {\r\n      // Create a unique key for this message to prevent duplicates\r\n      const messageKey = `${receiverId}-${content}-${Date.now()}`;\r\n      \r\n      if (this.pendingMessages.has(messageKey)) {\r\n        console.log('⚠️ Duplicate message detected, skipping:', messageKey);\r\n        return;\r\n      }\r\n      \r\n      this.pendingMessages.add(messageKey);\r\n      \r\n      // Remove from pending after 10 seconds\r\n      setTimeout(() => {\r\n        this.pendingMessages.delete(messageKey);\r\n      }, 10000);\r\n      \r\n      console.log('📤 Sending message:', { receiverId, content: content.substring(0, 50), messageKey });\r\n      this.socket.emit('sendMessage', { receiverId, content, messageType });\r\n    } else {\r\n      console.warn('⚠️ Socket not connected, cannot send message');\r\n    }\r\n  }\r\n\r\n  onMessage(callback: MessageCallback) {\r\n    this.messageCallbacks.push(callback);\r\n    return () => this.removeMessageCallback(callback);\r\n  }\r\n\r\n  onUserOnline(callback: UserOnlineCallback) {\r\n    this.userOnlineCallbacks.push(callback);\r\n    return () => this.removeUserOnlineCallback(callback);\r\n  }\r\n\r\n  onUserOffline(callback: UserOfflineCallback) {\r\n    this.userOfflineCallbacks.push(callback);\r\n    return () => this.removeUserOfflineCallback(callback);\r\n  }\r\n\r\n  // Keep for backward compatibility\r\n  onUserStatus(callback: UserOnlineCallback) {\r\n    return this.onUserOnline(callback);\r\n  }\r\n\r\n  onTyping(callback: TypingCallback) {\r\n    this.typingCallbacks.push(callback);\r\n    return () => this.removeTypingCallback(callback);\r\n  }\r\n\r\n  sendTypingStatus(receiverId: string, isTyping: boolean) {\r\n    if (this.socket && this.socket.connected) {\r\n      this.socket.emit('typing', { receiverId, isTyping });\r\n    }\r\n  }\r\n\r\n  markAsRead(senderId: string) {\r\n    if (this.socket && this.socket.connected) {\r\n      this.socket.emit('markAsRead', { senderId });\r\n    }\r\n  }\r\n\r\n  off(event: string) {\r\n    if (this.socket) {\r\n      this.socket.off(event);\r\n    }\r\n  }\r\n\r\n  getSocket() {\r\n    return this.socket;\r\n  }\r\n\r\n  // Add method to get current connection status more reliably\r\n  getConnectionStatus() {\r\n    return {\r\n      isConnected: this.socket && this.socket.connected,\r\n      socket: this.socket,\r\n      currentToken: this.currentToken,\r\n      reconnectAttempts: this.reconnectAttempts\r\n    };\r\n  }\r\n\r\n  // Force state sync for debugging\r\n  forceStateSync() {\r\n    console.log('🔍 Socket state debug:', {\r\n      hasSocket: !!this.socket,\r\n      isConnected: this.socket?.connected,\r\n      socketId: this.socket?.id,\r\n      currentToken: !!this.currentToken,\r\n      reconnectAttempts: this.reconnectAttempts\r\n    });\r\n    return this.socket && this.socket.connected;\r\n  }\r\n\r\n  private removeMessageCallback(callback: MessageCallback) {\r\n    this.messageCallbacks = this.messageCallbacks.filter(cb => cb !== callback);\r\n  }\r\n\r\n  private removeUserOnlineCallback(callback: UserOnlineCallback) {\r\n    this.userOnlineCallbacks = this.userOnlineCallbacks.filter(cb => cb !== callback);\r\n  }\r\n\r\n  private removeUserOfflineCallback(callback: UserOfflineCallback) {\r\n    this.userOfflineCallbacks = this.userOfflineCallbacks.filter(cb => cb !== callback);\r\n  }\r\n\r\n  private removeTypingCallback(callback: TypingCallback) {\r\n    this.typingCallbacks = this.typingCallbacks.filter(cb => cb !== callback);\r\n  }\r\n}\r\n\r\nexport const socketService = new SocketService();\r\nexport default socketService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}